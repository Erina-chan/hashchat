#!/usr/bin/env python3
import socket
from threading import Thread
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from datetime import datetime
from src.socks import receive, receive_session, receive_aes, send, PORT, exchange_ecdh
from src.keys import login
from src.contacts import load_contacts, save_contacts
from src.ui import *
from src.fingerprints import create_fingerprint, verify_fingerprint

from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, load_pem_public_key

from src.hashchain import message_x, verify_prev_hash
from src.block import *


def print_banner():
    """Prints the entry banner."""
    print_green("/////////////////////")
    print_green("// s l y t h e r ////")
    print_green("////// s e r v e r //")
    print_green("/////////////////////")


def get_contact_id(ip, contacts):
    """
    Given an IP address, finds the corresponding contact ID.

    Args:
        ip: The ip address to match with a contact name.
        contacts: The contacts dictionary to search.

    Return:
        The ID of the contact if the IP is known, otherwise the IP.
    """
    for contact_id in contacts:
        if contacts[contact_id]["ip"] == ip:
            return contact_id
    return ip


def handle_client(sock, addr, public, private, public_ecdh, private_ecdh):
    """
    Thread that receives a message from a connection.

    Args:
        sock: The socket the client has connected on.
        addr: Tuple of the IP address and port of the connection.
        public: The public RSA key of this user.
        private: The private RSA key of this user.
        public_ecdh: The public ECDH key of this user.
        private_ecdh: The private ECDh key of this user.
    """
    contacts = load_contacts(private)
    contact_id = get_contact_id(addr[0], contacts)
    
    if contact_id in contacts:
        print_green("New connection from {}!".format(contacts[contact_id]["name"]))
    else:
        print_green("New connection from {}!".format(contact_id))
    
    try:
        print(" > Performing RSA key exchange...")
        client_public = RSA.import_key(receive(sock))
        print("    : Received RSA public key.")
        
        # Check fingerprint
        if contact_id in contacts and contacts[contact_id]["fingerprint"] is not None:
            print(contacts[contact_id]["fingerprint"])
            if not verify_fingerprint(client_public, contacts[contact_id]["fingerprint"]):
                print_yellow("    : Fingerprint mismatch. Untrusted.")

        send(sock, public.export_key())
        print("    : Sent RSA public key.")

        send(sock, public_ecdh.public_bytes(encoding=Encoding.PEM, format=PublicFormat.SubjectPublicKeyInfo))
        print("    : Sent ECDH public key.")

        print(" > Performing ECDH key exchange...")
        client_public_ecdh = load_pem_public_key(receive(sock))
        print("    : Received ECDH public key.")

        print(" > Receiving message...")
        session_key = receive_session(sock, client_public, private)
        print("    : Received session key.")
        message = receive_aes(sock, client_public, session_key)
        print("    : Received message.")

        seed = exchange_ecdh(private_ecdh, client_public_ecdh)
        print(seed)

        x = message_x(seed, 0, message)
        print(x)

        ## RECEIVE BLOCK AND THIS SIGNATURE

    except ValueError as e:
        print_red("    : Error receiving message.")
        print(e)
    except OSError:
        print_red("    : Connection lost. Message not recieved.")
    else:
        print(" > Storing message...")

        message_receipt = { "time": datetime.now().strftime("%m/%d/%y %I:%M%p"), 
                            "recieved": True,
                            "contents": message.decode() }
        if contact_id in contacts:
            # Edit message if untrusted 
            if contacts[contact_id]["fingerprint"] is not None and not verify_fingerprint(client_public, contacts[contact_id]["fingerprint"]):
                message_receipt = { "time": datetime.now().strftime("%m/%d/%y %I:%M%p"), 
                                    "recieved": True,
                                    "contents": "!UNTRUSTED! {} !UNTRUSTED!".format(message.decode()) }
            
            if len(contacts[contact_id]["hashchain"]) > 0:
                last_block = block(contacts[contact_id]["hashchain"][-1]["prev_hash"], contacts[contact_id]["hashchain"][-1]["message_x"]) 
                prev_block_hash = last_block.hash()
                my_block = { "prev_hash": prev_block_hash,
                             "message_x": message_x(seed, contacts[contact_id]["counter"]+1, message)}
            else:
                my_block = { "prev_hash": "0000000000000000000000000000000000000000000000000000000000000000",
                             "message_x": message_x(seed, 1, message)}
            
            # Verify my_block and recived_block hashes (error: collision?)
            # Verify block signature
            if True:
                contacts[contact_id]["messages"].append(message_receipt)
                contacts[contact_id]["counter"] = contacts[contact_id]["counter"] + 1
                contacts[contact_id]["hashchain"].append(my_block) 
                contacts[contact_id]["contact_last_sign"] = None # signature
        else:
            my_block = { "prev_hash": "0000000000000000000000000000000000000000000000000000000000000000",
                         "message_x": message_x(seed, 1, message)}

            # Verify my_block and recived_block hashes (error: collision?)
            # Verify block signature
            if True:
                contacts[contact_id] = {  "name": contact_id,
                                            "ip": addr[0],
                                            "fingerprint": create_fingerprint(client_public),
                                            "messages": [message_receipt],
                                            "counter": 1, 
                                            "my_last_sign": None, 
                                            "contact_last_sign": None, # signature
                                            "hashchain": [message_block] }

        save_contacts(contacts, private)
    finally:
        print(" > Closing connection...\n")
        sock.close()
        

if __name__ == "__main__":
    print_banner()
    # Load keys
    private, public, private_ecdh, public_ecdh= login()


    # Bind socket
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            server_addr = ("0.0.0.0", PORT)
            sock.bind(server_addr)
            sock.listen(5)

            # Acceptance loop
            print("Listening for connections...")
            while True:
                try:
                    connection, addr = sock.accept()
                    connection_thread = Thread( target=handle_client, 
                                                args=(connection, addr, public, private, public_ecdh, private_ecdh))
                    connection_thread.start()
                except KeyboardInterrupt:
                    if confirm("\nAre you sure you'd like to close slyther-server? (Y/n) "):
                       break 
    except OSError:
        print_red("Error: Failed to start slyther-server: Port {} in use.".format(PORT))


